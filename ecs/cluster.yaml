---
AWSTemplateFormatVersion: '2010-09-09'

Description: 'ECS: Elastic Container Service cluster'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: 'Parent Stacks'
        Parameters:
          - ParentVPCStack
          - ParentEFSStack
          - ParentAlertStack

      - Label:
          default: 'VPC Parameters'
        Parameters:
          - VPCTier

      - Label:
          default: 'EC2 Parameters'
        Parameters:
          - ECSAMI
          - KeyName
          - DockerAuthType
          - DockerAuthData
          - EFSDirectory

      - Label:
          default: 'Load Balancer Parameters'
        Parameters:
          - LoadBalancerScheme
          - LoadBalancerCertificateArn

      - Label:
          default: 'Cluster Parameters'
        Parameters:
          - InstanceType
          - SpotPrice
          - LogsRetentionInDays
          - MaxSize
          - MinSize
          - DesiredCapacity
          - DrainingTimeoutInSeconds
          - AnchoreConfigBucket

      - Label:
          default: 'Cluster Scaling Parameters'
        Parameters:
          - ContainerMaxCPU
          - ContainerMaxMemory
          - ContainerShortageThreshold
          - ContainerExcessThreshold

Parameters:
  ParentVPCStack:
    Description: 'Stack name of parent VPC stack based on vpc/vpc-*tier.yaml template.'
    Type: String

  ParentEFSStack:
    Description: 'Optional but recommended stack name of parent EFS stack based on efs/volume.yaml template.'
    Type: String
    Default: ''

  ParentAlertStack:
    Description: 'Optional but recommended stack name of parent alert stack based on operations/alert.yaml template.'
    Type: String
    Default: ''

  VPCTier:
    Description: 'Which VPC Tier'
    Type: String
    Default: Private
    AllowedValues: ['Public','Private','Data']

  ECSAMI:
    Description: AMI ID
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ecs/optimized-ami/amazon-linux/recommended/image_id

  KeyName:
    Description: 'Optional key pair of the ec2-user to establish a SSH connection to the EC2 instances of the ECS cluster.'
    Type: String
    Default: ''

  DockerAuthType:
    Description: 'Optional Docker format for private registry authentication.'
    Type: String
    Default: ''
    AllowedValues:
      - ''
      - 'dockercfg'
      - 'docker'

  DockerAuthData:
    Description: 'Optional Docker private registry authentication JSON data.'
    Type: String
    NoEcho: True
    Default: ''

  EFSDirectory:
    Description: 'Optional EFS mountpoint directory to use. Requires ParentEFSStack parameter!'
    Type: String
    Default: /mnt/efs

  LoadBalancerScheme:
    Description: 'Indicates whether the load balancer in front of the ECS cluster is internet-facing or internal.'
    Type: String
    Default: 'internet-facing'
    AllowedValues:
      - 'internet-facing'
      - internal

  LoadBalancerCertificateArn:
    Description: 'Optional Amazon Resource Name (ARN) of the certificate to associate with the load balancer.'
    Type: String
    Default: ''

  InstanceType:
    Description: 'The instance type of the EC2 instances of the ECS cluster.'
    Type: String
    Default: 't2.micro'

  SpotPrice:
    Description: 'Optional Spot Price to run the EC2 instances of the ECS cluster.'
    Type: String
    Default: ''

  LogsRetentionInDays:
    Description: 'Specifies the number of days you want to retain log events in the specified log group.'
    Type: Number
    Default: 14
    AllowedValues: [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 3653]

  MaxSize:
    Description: 'The maximum size of the Auto Scaling group.'
    Type: Number
    Default: 4
    ConstraintDescription: 'Must be >= 1'
    MinValue: 1

  MinSize:
    Description: 'The minimum size of the Auto Scaling group.'
    Type: Number
    Default: 2
    ConstraintDescription: 'Must be >= 1'
    MinValue: 1

  DesiredCapacity:
    Description: 'The desired start size of the Auto Scaling group.'
    Type: Number
    Default: 2
    ConstraintDescription: 'Must be >= 1'
    MinValue: 1

  DrainingTimeoutInSeconds:
    Description: 'Maximum time in seconds an EC2 instance waits when terminating until all containers are moved to another EC2 instance (draining).'
    Type: Number
    Default: 60
    ConstraintDescription: 'Must be in the range [60-7200]'
    MinValue: 60
    MaxValue: 7200

  AnchoreConfigBucket:
    Description: 'Optional S3 Bucket holding Anchore Container Scanning configs.'
    Type: String
    Default: ''

  ContainerMaxCPU:
    Description: 'The maximum number of cpu reservation per container that you plan to run on this cluster. A container instance has 1,024 CPU units for every CPU core.'
    Type: Number
    Default: 128

  ContainerMaxMemory:
    Description: 'The maximum number of memory reservation (in MB)  per container that you plan to run on this cluster.'
    Type: Number
    Default: 128

  ContainerShortageThreshold:
    Description: 'Scale up if free cluster capacity <= containers (based on ContainerMaxCPU and ContainerMaxMemory settings)'
    Type: Number
    Default: 2
    MinValue: 0
    ConstraintDescription: 'Must be >= 0'

  ContainerExcessThreshold:
    Description: 'Scale down if free cluster capacity >= containers (based on ContainerMaxCPU and ContainerMaxMemory settings)'
    Type: Number
    Default: 10
    MinValue: 2
    ConstraintDescription: 'Must be >= 2'

Conditions:
  HasKeyName: !Not [!Equals [!Ref KeyName, '']]
  HasLoadBalancerSchemeInternal: !Equals [!Ref LoadBalancerScheme, 'internal']
  HasLoadBalancerCertificateArn: !Not [!Equals [!Ref LoadBalancerCertificateArn, '']]
  HasEFSVolume: !Not [!Equals [!Ref ParentEFSStack, '']]
  HasAlertTopic: !Not [!Equals [!Ref ParentAlertStack, '']]
  HasSpotPrice: !Not [!Equals [!Ref SpotPrice, '']]
  HasAnchore: !Not [!Equals [!Ref AnchoreConfigBucket, '']]

Resources:
  Cluster:
    Type: AWS::ECS::Cluster
    Properties: {}

  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      RetentionInDays: !Ref LogsRetentionInDays

  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref Role

  Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - 'ec2.amazonaws.com'
                - 'ssm.amazonaws.com'
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonEC2RoleforSSM
      Path: /
      Policies:
        - PolicyName: ecs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecs:DiscoverPollEndpoint
                  - ecs:StartTask
                Resource: '*'
        - PolicyName: ecs-cluster
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecs:DeregisterContainerInstance
                  - ecs:RegisterContainerInstance
                  - ecs:SubmitContainerStateChange
                  - ecs:SubmitTaskStateChange
                  - ecs:ListContainerInstances
                Resource: !GetAtt 'Cluster.Arn'
        - PolicyName: ecs-cluster-instance
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecs:Poll
                  - ecs:StartTelemetrySession
                  - ecs:UpdateContainerInstancesState
                  - ecs:ListTasks
                  - ecs:DescribeContainerInstances
                Resource: !Sub "arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:container-instance/*"
                Condition:
                  'StringEquals':
                    'ecs:cluster': !GetAtt 'Cluster.Arn'
        - PolicyName: ecr
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                Resource: '*'
        - PolicyName: logs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:DescribeLogStreams
                Resource: !Sub "arn:aws:logs:${AWS::Region}:*:*"
        - PolicyName: autoscaling
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - autoscaling:CompleteLifecycleAction
                Resource: '*'
        - PolicyName: sqs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sqs:DeleteMessage
                  - sqs:ReceiveMessage
                Resource: !GetAtt 'AutoScalingGroupLifecycleHookQueue.Arn'

  ALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: 'ecs-cluster-alb'
      VpcId:
        Fn::ImportValue: !Sub "${ParentVPCStack}-VPC"

  ALBSecurityGroupInHttpWorld:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref ALBSecurityGroup
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80
      CidrIp: '0.0.0.0/0'

  ALBSecurityGroupInHttpsWorld:
    Type: AWS::EC2::SecurityGroupIngress
    Condition: HasLoadBalancerCertificateArn
    Properties:
      GroupId: !Ref ALBSecurityGroup
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      CidrIp: '0.0.0.0/0'

  SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: 'ecs-cluster'
      VpcId:
        Fn::ImportValue: !Sub "${ParentVPCStack}-VPC"
      SecurityGroupIngress:
        - SourceSecurityGroupId: !Ref ALBSecurityGroup
          FromPort: 0
          ToPort: 65535
          IpProtocol: tcp

  SecurityGroupInSSHWorld:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref SecurityGroup
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      CidrIp: '0.0.0.0/0'

  HTTPCodeELB5XXTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Application load balancer returns 5XX HTTP status codes'
      Namespace: 'AWS/ApplicationELB'
      MetricName: HTTPCode_ELB_5XX_Count
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 0
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"
      Dimensions:
        - Name: LoadBalancer
          Value: !GetAtt 'LoadBalancer.LoadBalancerFullName'
        - Name: TargetGroup
          Value: !GetAtt 'DefaultTargetGroup.TargetGroupFullName'

  HTTPCodeTarget5XXTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Application load balancer receives 5XX HTTP status codes from targets'
      Namespace: 'AWS/ApplicationELB'
      MetricName: HTTPCode_Target_5XX_Count
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 0
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"
      Dimensions:
        - Name: LoadBalancer
          Value: !GetAtt 'LoadBalancer.LoadBalancerFullName'
        - Name: TargetGroup
          Value: !GetAtt 'DefaultTargetGroup.TargetGroupFullName'

  RejectedConnectionCountTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Application load balancer rejected connections because the load balancer had reached its maximum number of connections'
      Namespace: 'AWS/ApplicationELB'
      MetricName: RejectedConnectionCount
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 0
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"
      Dimensions:
        - Name: LoadBalancer
          Value: !GetAtt 'LoadBalancer.LoadBalancerFullName'
        - Name: TargetGroup
          Value: !GetAtt 'DefaultTargetGroup.TargetGroupFullName'

  TargetConnectionErrorCountTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Application load balancer could not connect to targets'
      Namespace: 'AWS/ApplicationELB'
      MetricName: TargetConnectionErrorCount
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 0
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"
      Dimensions:
        - Name: LoadBalancer
          Value: !GetAtt 'LoadBalancer.LoadBalancerFullName'
        - Name: TargetGroup
          Value: !GetAtt 'DefaultTargetGroup.TargetGroupFullName'

  LoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: !Ref LoadBalancerScheme
      SecurityGroups:
        - !Ref ALBSecurityGroup
      Subnets: !If
        - HasLoadBalancerSchemeInternal
        - !Split
          - ','
          - Fn::ImportValue:
              !Sub '${ParentVPCStack}-SubnetsPrivate'
        - !Split
          - ','
          - Fn::ImportValue:
              !Sub '${ParentVPCStack}-SubnetsPublic'

  DefaultTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 15
      HealthCheckPort: 51678
      HealthCheckPath: '/'
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 10
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 2
      Matcher:
        HttpCode: '200-299'
      Port: 80
      Protocol: HTTP
      VpcId:
        Fn::ImportValue: !Sub "${ParentVPCStack}-VPC"
      TargetGroupAttributes:
        - Key: 'deregistration_delay.timeout_seconds'
          Value: 0

  HttpListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref DefaultTargetGroup
          Type: forward
      LoadBalancerArn: !Ref LoadBalancer
      Port: 80
      Protocol: HTTP

  HttpsListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Condition: HasLoadBalancerCertificateArn
    Properties:
      Certificates:
        - CertificateArn: !Ref LoadBalancerCertificateArn
      DefaultActions:
        - TargetGroupArn: !Ref DefaultTargetGroup
          Type: forward
      LoadBalancerArn: !Ref LoadBalancer
      SslPolicy: ELBSecurityPolicy-FS-2018-06
      Port: 443
      Protocol: HTTPS

  LaunchConfiguration:
    Type: AWS::AutoScaling::LaunchConfiguration
    Metadata:
      AWS::CloudFormation::Init:
        configSets:
          default:
            - ssm
            - awslogs
            - !If [HasEFSVolume, efsmount, !Ref 'AWS::NoValue']
            - ecs
            - install
            - !If [HasAnchore, anchore, !Ref 'AWS::NoValue']
        ssm:
          packages:
            rpm:
              amazon-ssm-agent: https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/linux_amd64/amazon-ssm-agent.rpm
        efsmount:
          packages:
            yum:
              'amazon-efs-utils': []
          commands:
            a_mountpoint_mkdir:
              command: !Sub 'mkdir ${EFSDirectory}'
              test: !Sub '[ ! -d ${EFSDirectory} ]'
            b_mountpoint_mount:
              command: !Sub
                - 'while ! (echo > /dev/tcp/${FileSystem}.efs.${AWS::Region}.amazonaws.com/2049) >/dev/null 2>&1; do sleep 10; done && sleep 10 && mount -t efs ${FileSystem}:/ ${EFSDirectory} && chmod 1777 ${EFSDirectory}'
                - FileSystem: !If [HasEFSVolume, {'Fn::ImportValue': !Sub "${ParentEFSStack}-FileSystem"}, '']
              test: !Sub 'if mount | grep -q ${EFSDirectory}; then exit 1; else exit 0; fi'
            c_mountpount_fstab:
              command: !Sub
                - 'echo "${FileSystem}:/ ${EFSDirectory} efs defaults,_netdev 0 0" |tee -a /etc/fstab'
                - FileSystem: !If [HasEFSVolume, {'Fn::ImportValue': !Sub "${ParentEFSStack}-FileSystem"}, '']
              test: !Sub 'if grep -q ${EFSDirectory} /etc/fstab; then exit 1; else exit 0; fi'
        ecs:
          files:
            /etc/ecs/ecs.config:
              content: !Sub |
                ECS_CLUSTER=${Cluster}
                ECS_ENGINE_AUTH_TYPE=${DockerAuthType}
                ECS_ENGINE_AUTH_DATA=${DockerAuthData}
        awslogs:
          packages:
            yum:
              awslogs: []
          files:
            /etc/awslogs/awscli.conf:
              content: !Sub |
                [default]
                region = ${AWS::Region}
                [plugins]
                cwlogs = cwlogs
              mode: '000644'
              owner: root
              group: root
            /etc/awslogs/awslogs.conf:
              content: !Sub |
                [general]
                state_file = /var/lib/awslogs/agent-state
                [/var/log/messages]
                datetime_format = %b %d %H:%M:%S
                file = /var/log/messages
                log_stream_name = {instance_id}/var/log/messages
                log_group_name = ${LogGroup}
                [/var/log/secure]
                datetime_format = %b %d %H:%M:%S
                file = /var/log/secure
                log_stream_name = {instance_id}/var/log/secure
                log_group_name = ${LogGroup}
                [/var/log/cron]
                datetime_format = %b %d %H:%M:%S
                file = /var/log/cron
                log_stream_name = {instance_id}/var/log/cron
                log_group_name = ${LogGroup}
                [/var/log/cloud-init.log]
                datetime_format = %b %d %H:%M:%S
                file = /var/log/cloud-init.log
                log_stream_name = {instance_id}/var/log/cloud-init.log
                log_group_name = ${LogGroup}
                [/var/log/cfn-init.log]
                datetime_format = %Y-%m-%d %H:%M:%S
                file = /var/log/cfn-init.log
                log_stream_name = {instance_id}/var/log/cfn-init.log
                log_group_name = ${LogGroup}
                [/var/log/cfn-hup.log]
                datetime_format = %Y-%m-%d %H:%M:%S
                file = /var/log/cfn-hup.log
                log_stream_name = {instance_id}/var/log/cfn-hup.log
                log_group_name = ${LogGroup}
                [/var/log/cfn-init-cmd.log]
                datetime_format = %Y-%m-%d %H:%M:%S
                file = /var/log/cfn-init-cmd.log
                log_stream_name = {instance_id}/var/log/cfn-init-cmd.log
                log_group_name = ${LogGroup}
                [/var/log/cloud-init-output.log]
                file = /var/log/cloud-init-output.log
                log_stream_name = {instance_id}/var/log/cloud-init-output.log
                log_group_name = ${LogGroup}
                [/var/log/dmesg]
                file = /var/log/dmesg
                log_stream_name = {instance_id}/var/log/dmesg
                log_group_name = ${LogGroup}
              mode: '000644'
              owner: root
              group: root
          services:
            sysvinit:
              awslogs:
                enabled: true
                ensureRunning: true
                packages:
                  yum:
                    - awslogs
                files:
                  - /etc/awslogs/awslogs.conf
                  - /etc/awslogs/awscli.conf
        install:
          packages:
            yum:
              ruby: []
            rubygems:
              'aws-sdk':
                - '3.0.1'
              daemons:
                - '1.2.5'
          files:
            /etc/cfn/cfn-hup.conf:
              content: !Sub |
                [main]
                stack=${AWS::StackId}
                region=${AWS::Region}
                interval=1
              mode: '000400'
              owner: root
              group: root
            /etc/cfn/hooks.d/cfn-auto-reloader.conf:
              content: !Sub |
                [cfn-auto-reloader-hook]
                triggers=post.update
                path=Resources.LaunchConfiguration.Metadata.AWS::CloudFormation::Init
                action=/opt/aws/bin/cfn-init --verbose --stack=${AWS::StackName} --region=${AWS::Region} --resource=LaunchConfiguration
                runas=root
            /etc/init.d/lifecycle-poller:
              content: |
                #!/usr/bin/env ruby
                # chkconfig:    - 80 20
                APP_NAME = 'lifecycle-poller'
                APP_PATH = '/opt/lifecycle-poller/daemon.rb'
                case ARGV.first
                  when 'start'
                    puts "Starting #{APP_NAME}..."
                    system(APP_PATH, 'start')
                    exit($?.exitstatus)
                  when 'stop'
                    system(APP_PATH, 'stop')
                    exit($?.exitstatus)
                  when 'restart'
                    system(APP_PATH, 'restart')
                    exit($?.exitstatus)
                  when 'status'
                    system(APP_PATH, 'status')
                    exit($?.exitstatus)
                end
                unless %w{start stop restart status}.include? ARGV.first
                  puts "Usage: #{APP_NAME} {start|stop|restart|status}"
                  exit(1)
                end
              mode: '000755'
              owner: root
              group: root
            /opt/lifecycle-poller/poller.conf:
              content: !Sub |
                region: ${AWS::Region}
                cluster: ${Cluster}
                queueUrl: ${AutoScalingGroupLifecycleHookQueue}
                maxWaitInSeconds: ${DrainingTimeoutInSeconds}
              mode: '000400'
              owner: root
              group: root
            /opt/lifecycle-poller/daemon.rb:
              content: |
                #!/usr/bin/env ruby
                require 'daemons'
                Daemons.run(__dir__ + '/worker.rb', {:monitor => true, :log_output_syslog => true})
              mode: '000500'
              owner: root
              group: root
            /opt/lifecycle-poller/worker.rb:
              content: |
                #!/usr/bin/env ruby
                require 'net/http'
                require 'aws-sdk'
                require 'json'
                require 'uri'
                require 'yaml'
                require 'syslog/logger'
                $log = Syslog::Logger.new 'poller'
                $conf = YAML::load_file(__dir__ + '/poller.conf')
                Aws.config.update(region: $conf['region'])
                $log.info 'poller started'
                def fetchContainerInstanceId(ec2InstanceId)
                  ecs = Aws::ECS::Client.new()
                  resp1 = ecs.list_container_instances({
                    cluster: $conf['cluster']
                  })
                  resp2 = ecs.describe_container_instances({
                    cluster: $conf['cluster'],
                    container_instances: resp1.container_instance_arns,
                  })
                  cis = resp2.container_instances.select {|ci| ci.ec2_instance_id == ec2InstanceId}
                  if cis.first().nil?
                    return nil
                  else
                    return cis.first().container_instance_arn.split("/").last()
                  end
                end
                def drainContainerInstanceId(containerInstanceId)
                  ecs = Aws::ECS::Client.new()
                  ecs.update_container_instances_state({
                    cluster: $conf['cluster'],
                    container_instances: [containerInstanceId],
                    status: "DRAINING"
                  })

                end
                def isContainerInstanceIdle(containerInstanceId)
                  ecs = Aws::ECS::Client.new()
                  resp = ecs.list_tasks({
                    cluster: $conf['cluster'],
                    container_instance: containerInstanceId
                  })
                  return resp.task_arns.empty?
                end
                def awaitContainerInstanceIdle(containerInstanceId)
                  endTime = Time.now.to_i + $conf['maxWaitInSeconds']
                  while Time.now.to_i < endTime do
                    if isContainerInstanceIdle containerInstanceId
                      $log.info "container instance #{containerInstanceId} is idle"
                      return true
                    end
                    sleep 5 # seconds
                  end
                  $log.error "container instance #{containerInstanceId} is not idle, but wait time elapsed"
                  return false
                end
                def deregisterContainerInstance(containerInstanceId)
                  ecs = Aws::ECS::Client.new()
                  resp = ecs.deregister_container_instance({
                    cluster: $conf['cluster'],
                    container_instance: containerInstanceId,
                    force: false
                  })
                end
                def completeLifecycleAction(token, hook, asg)
                  begin
                    autoscaling = Aws::AutoScaling::Client.new()
                    autoscaling.complete_lifecycle_action(
                      lifecycle_hook_name: hook,
                      auto_scaling_group_name: asg,
                      lifecycle_action_token: token,
                      lifecycle_action_result: 'CONTINUE'
                    )
                    $log.info "Lifecycle action completed"
                    return true
                  rescue Exception => e
                    if e.code == 'ValidationError'
                      $log.info "Lifecycle action failed validation: #{e.inspect}"
                      return true
                    else
                      raise e
                    end
                  end
                end
                def pollSQS()
                  poller = Aws::SQS::QueuePoller.new($conf['queueUrl'])
                  poller.poll do |msg|
                    begin
                      body = JSON.parse(msg.body)
                      $log.debug "message #{body}"
                      if body['Event'] == 'autoscaling:TEST_NOTIFICATION'
                        $log.info 'received test notification'
                      else
                        if body['LifecycleTransition'] == 'autoscaling:EC2_INSTANCE_TERMINATING'
                          $log.info "lifecycle transition for EC2 instance #{body['EC2InstanceId']}"
                          containerInstanceId = fetchContainerInstanceId body['EC2InstanceId']
                          if containerInstanceId.nil?
                            $log.info "no container instance found for EC2 instance #{body['EC2InstanceId']}"
                          else
                            $log.info "lifecycle transition for container instance #{containerInstanceId}"
                            drainContainerInstanceId containerInstanceId
                            awaitContainerInstanceIdle containerInstanceId
                            deregisterContainerInstance containerInstanceId
                          end
                          completeLifecycleAction body['LifecycleActionToken'], body['LifecycleHookName'], body['AutoScalingGroupName']
                        else
                          $log.error "received unsupported lifecycle transition: #{body['LifecycleTransition']}"
                        end
                      end
                    rescue Exception => e
                      $log.error "message failed: #{e.inspect} #{msg.inspect}"
                      raise e
                    end
                  end
                end
                pollSQS
              mode: '000500'
              owner: root
              group: root
          services:
            sysvinit:
              cfn-hup:
                enabled: true
                ensureRunning: true
                files:
                  - /etc/cfn/cfn-hup.conf
                  - /etc/cfn/hooks.d/cfn-auto-reloader.conf
              lifecycle-poller:
                enabled: true
                ensureRunning: true
                files:
                  - /etc/init.d/lifecycle-poller
                  - /opt/lifecycle-poller/poller.conf
                  - /opt/lifecycle-poller/daemon.rb
                  - /opt/lifecycle-poller/worker.rb
        anchore:
          files:
            /mnt/efs/anchore/config.yaml:
              source: !Sub "https://s3.amazonaws.com/${AnchoreConfigBucket}/anchore/config.yaml"
              owner: root
              group: root
              mode: '000644'
            /mnt/efs/anchore/config-ui.yaml:
              source: !Sub "https://s3.amazonaws.com/${AnchoreConfigBucket}/anchore/config-ui.yaml"
              owner: root
              group: root
              mode: '000644'
            /mnt/efs/anchore/license.yaml:
              source: !Sub "https://s3.amazonaws.com/${AnchoreConfigBucket}/anchore/license.yaml"
              owner: root
              group: root
              mode: '000644'
      AWS::CloudFormation::Authentication:
        S3AccessCreds:
          type: "S3"
          roleName: !Ref Role
          buckets:
            - !If [HasAnchore, !Ref AnchoreConfigBucket, !Ref 'AWS::NoValue']
    Properties:
      ImageId: !Ref ECSAMI
      IamInstanceProfile: !Ref InstanceProfile
      InstanceType: !Ref InstanceType
      SecurityGroups:
        - !GetAtt SecurityGroup.GroupId
        - Fn::ImportValue: !Sub "${ParentVPCStack}-SecurityGroup"
        - !If [HasEFSVolume, {'Fn::ImportValue': !Sub "${ParentEFSStack}-SecurityGroup"}, !Ref 'AWS::NoValue']
      KeyName: !If [HasKeyName, !Ref KeyName, !Ref 'AWS::NoValue']
      SpotPrice: !If [HasSpotPrice, !Ref SpotPrice, !Ref 'AWS::NoValue']
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -x
          bash -ex << "TRY"
            yum install -y aws-cfn-bootstrap
            /opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource LaunchConfiguration --region ${AWS::Region}
          TRY
          /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource AutoScalingGroup --region ${AWS::Region}

  AutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      LaunchConfigurationName: !Ref LaunchConfiguration
      MinSize: !If [HasSpotPrice, 0, !Ref MinSize]
      MaxSize: !Ref MaxSize
      DesiredCapacity: !Ref DesiredCapacity
      HealthCheckGracePeriod: 300
      HealthCheckType: ELB
      TargetGroupARNs:
        - !Ref DefaultTargetGroup
      NotificationConfigurations: !If
        - HasAlertTopic
        - - NotificationTypes:
              - 'autoscaling:EC2_INSTANCE_LAUNCH_ERROR'
              - 'autoscaling:EC2_INSTANCE_TERMINATE_ERROR'
            TopicARN:
              Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"
        - !Ref 'AWS::NoValue'
      VPCZoneIdentifier: !Split
        - ','
        - Fn::ImportValue:
            !Sub "${ParentVPCStack}-Subnets${VPCTier}"
      Tags:
        - Key: Name
          Value: !Ref 'AWS::StackName'
          PropagateAtLaunch: true
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy:
      AutoScalingRollingUpdate:
        PauseTime: PT15M
        MinInstancesInService: !If [HasSpotPrice, 0, !Ref MinSize]
        SuspendProcesses:
          - HealthCheck
          - ReplaceUnhealthy
          - AZRebalance
          - AlarmNotification
          - ScheduledActions
        WaitOnResourceSignals: true

  CPUTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Average CPU utilization over last 10 minutes higher than 80%'
      Namespace: 'AWS/EC2'
      MetricName: CPUUtilization
      Statistic: Average
      Period: 600
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 80
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"
      Dimensions:
        - Name: AutoScalingGroupName
          Value: !Ref AutoScalingGroup

  AutoScalingGroupLifecycleHookQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub "${AWS::StackName}-lifecycle-hook"
      VisibilityTimeout: !Ref DrainingTimeoutInSeconds
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt 'AutoScalingGroupLifecycleHookDeadLetterQueue.Arn'
        maxReceiveCount: 5

  AutoScalingGroupLifecycleHookQueueTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Queue contains messages older than 10 minutes, messages are not consumed'
      Namespace: 'AWS/SQS'
      MetricName: ApproximateAgeOfOldestMessage
      Statistic: Maximum
      Period: 60
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 600
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"
      Dimensions:
        - Name: QueueName
          Value: !GetAtt 'AutoScalingGroupLifecycleHookQueue.QueueName'

  AutoScalingGroupLifecycleHookDeadLetterQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub "${AWS::StackName}-lifecycle-hook-dlq"

  AutoScalingGroupLifecycleHookDeadLetterQueueTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Dead letter queue contains messages, message processing failed'
      Namespace: 'AWS/SQS'
      MetricName: ApproximateNumberOfMessagesVisible
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 0
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"
      Dimensions:
        - Name: QueueName
          Value: !GetAtt 'AutoScalingGroupLifecycleHookDeadLetterQueue.QueueName'

  AutoScalingGroupLifecycleHookIAMRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - 'autoscaling.amazonaws.com'
            Action:
              - 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: sqs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: write
                Effect: Allow
                Action:
                  - sqs:SendMessage
                  - sqs:GetQueueUrl
                Resource: !GetAtt 'AutoScalingGroupLifecycleHookQueue.Arn'

  AutoScalingGroupTerminatingLifecycleHook:
    Type: AWS::AutoScaling::LifecycleHook
    Properties:
      HeartbeatTimeout: !Ref DrainingTimeoutInSeconds
      DefaultResult: CONTINUE
      AutoScalingGroupName: !Ref AutoScalingGroup
      LifecycleTransition: 'autoscaling:EC2_INSTANCE_TERMINATING'
      NotificationTargetARN: !GetAtt 'AutoScalingGroupLifecycleHookQueue.Arn'
      RoleARN: !GetAtt 'AutoScalingGroupLifecycleHookIAMRole.Arn'

  ScaleUpPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AdjustmentType: PercentChangeInCapacity
      MinAdjustmentStep: 1
      AutoScalingGroupName: !Ref AutoScalingGroup
      Cooldown: 300
      ScalingAdjustment: 25

  ScaleDownPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AdjustmentType: PercentChangeInCapacity
      MinAdjustmentStep: 1
      AutoScalingGroupName: !Ref AutoScalingGroup
      Cooldown: 300
      ScalingAdjustment: -25

  ContainerInstancesShortageAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Cluster is running out of container instances'
      Namespace: !Ref 'AWS::StackName'
      Dimensions:
        - Name: ClusterName
          Value: !Ref Cluster
      MetricName: SchedulableContainers
      ComparisonOperator: LessThanOrEqualToThreshold
      Statistic: Minimum
      Period: 60
      EvaluationPeriods: 1
      Threshold: !Ref ContainerShortageThreshold
      AlarmActions:
        - !Ref ScaleUpPolicy

  ContainerInstancesExcessAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Cluster is wasting container instances'
      Namespace: !Ref 'AWS::StackName'
      Dimensions:
        - Name: ClusterName
          Value: !Ref Cluster
      MetricName: SchedulableContainers
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Statistic: Maximum
      Period: 60
      EvaluationPeriods: 1
      Threshold: !Ref ContainerExcessThreshold
      AlarmActions:
        - !Ref ScaleDownPolicy

  CPUReservationTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Average CPU reservation over last 10 minutes higher than 90%'
      Namespace: 'AWS/ECS'
      Dimensions:
        - Name: ClusterName
          Value: !Ref Cluster
      MetricName: CPUReservation
      ComparisonOperator: GreaterThanThreshold
      Statistic: Average
      Period: 600
      EvaluationPeriods: 1
      Threshold: 90
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"

  CPUUtilizationTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Average CPU utilization over last 10 minutes higher than 80%'
      Namespace: 'AWS/ECS'
      Dimensions:
        - Name: ClusterName
          Value: !Ref Cluster
      MetricName: CPUUtilization
      ComparisonOperator: GreaterThanThreshold
      Statistic: Average
      Period: 600
      EvaluationPeriods: 1
      Threshold: 80
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"

  MemoryReservationTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Average memory reservation over last 10 minutes higher than 90%'
      Namespace: 'AWS/ECS'
      Dimensions:
        - Name: ClusterName
          Value: !Ref Cluster
      MetricName: MemoryReservation
      ComparisonOperator: GreaterThanThreshold
      Statistic: Average # special rule because we scale on reservations and not utilization
      Period: 600
      EvaluationPeriods: 1
      Threshold: 90
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"

  MemoryUtilizationTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Average memory utilization over last 10 minutes higher than 80%'
      Namespace: 'AWS/ECS'
      Dimensions:
        - Name: ClusterName
          Value: !Ref Cluster
      MetricName: MemoryUtilization
      ComparisonOperator: GreaterThanThreshold
      Statistic: Average
      Period: 600
      EvaluationPeriods: 1
      Threshold: 80
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"

  SchedulableContainersRule:
    Type: AWS::Events::Rule
    Properties:
      EventPattern:
        source:
          - 'aws.ecs'
        'detail-type':
          - 'ECS Container Instance State Change'
      State: ENABLED
      Targets:
        - Arn: !GetAtt 'SchedulableContainersLambda.Arn'
          Id: lambda

  SchedulableContainersRuleFailedInvocationsTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Invocations failed permanently'
      Namespace: 'AWS/Events'
      MetricName: FailedInvocations
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 0
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"
      Dimensions:
        - Name: RuleName
          Value: !Ref SchedulableContainersRule

  SchedulableContainersCron:
    Type: AWS::Events::Rule
    Properties:
      ScheduleExpression: 'rate(1 minute)'
      State: ENABLED
      Targets:
        - Arn: !GetAtt 'SchedulableContainersLambda.Arn'
          Id: lambda

  SchedulableContainersCronFailedInvocationsTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Invocations failed permanently'
      Namespace: 'AWS/Events'
      MetricName: FailedInvocations
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 0
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"
      Dimensions:
        - Name: RuleName
          Value: !Ref SchedulableContainersCron

  SchedulableContainersLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: 'lambda.amazonaws.com'
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: logs
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
        - PolicyName: ecs
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - ecs:ListContainerInstances
                Resource: !GetAtt 'Cluster.Arn'
              - Effect: Allow
                Action:
                  - ecs:DescribeContainerInstances
                Resource: '*'
                Condition:
                  ArnEquals:
                    'ecs:cluster': !GetAtt 'Cluster.Arn'
        - PolicyName: cloudwatch
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                Resource: '*'

  SchedulableContainersLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref SchedulableContainersLambda
      Principal: 'events.amazonaws.com'
      SourceArn: !GetAtt 'SchedulableContainersRule.Arn'

  SchedulableContainersLambdaPermission2:
    Type: AWS::Lambda::Permission
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref SchedulableContainersLambda
      Principal: 'events.amazonaws.com'
      SourceArn: !GetAtt 'SchedulableContainersCron.Arn'

  SchedulableContainersLambda:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: !Sub |
          'use strict';
          const AWS = require('aws-sdk');
          const ecs = new AWS.ECS({apiVersion: '2014-11-13'});
          const cloudwatch = new AWS.CloudWatch({apiVersion: '2010-08-01'});
          const CONTAINER_MAX_CPU = ${ContainerMaxCPU};
          const CONTAINER_MAX_MEMORY = ${ContainerMaxMemory};
          const CLUSTER = '${Cluster}';
          const NAMESPACE = '${AWS::StackName}';
          function list(nextToken) {
            return ecs.listContainerInstances({
              cluster: CLUSTER,
              maxResults: 1,
              nextToken: nextToken,
              status: 'ACTIVE'
            }).promise();
          }
          function describe(containerInstanceArns) {
            return ecs.describeContainerInstances({
              cluster: CLUSTER,
              containerInstances: containerInstanceArns
            }).promise();
          }
          function compute(totalSchedulableContainers, nextToken) {
            return list(nextToken)
              .then((list) => {
                return describe(list.containerInstanceArns)
                  .then((data) => {
                    const localSchedulableContainers = data.containerInstances
                      .map((instance) => ({
                        cpu: instance.remainingResources.find((resource) => resource.name === 'CPU').integerValue,
                        memory: instance.remainingResources.find((resource) => resource.name === 'MEMORY').integerValue
                      }))
                      .map((remaining) => Math.min(Math.floor(remaining.cpu/CONTAINER_MAX_CPU), Math.floor(remaining.memory/CONTAINER_MAX_MEMORY)))
                      .reduce((acc, containers) => acc + containers, 0);
                    console.log(`localSchedulableContainers ${!localSchedulableContainers}`);
                    if (list.nextToken !== null && list.nextToken !== undefined) {
                      return compute(localSchedulableContainers + totalSchedulableContainers, list.nextToken);
                    } else {
                      return localSchedulableContainers + totalSchedulableContainers;
                    }
                  });
              });
          }
          exports.handler = (event, context, cb) => {
            console.log(`Invoke: ${!JSON.stringify(event)}`);
            compute(0, undefined)
              .then((schedulableContainers) => {
                console.log(`schedulableContainers: ${!schedulableContainers}`);
                return cloudwatch.putMetricData({
                  MetricData: [{
                    MetricName: 'SchedulableContainers',
                    Dimensions: [{
                      Name: 'ClusterName',
                      Value: CLUSTER
                    }],
                    Value: schedulableContainers,
                    Unit: 'Count'
                  }],
                  Namespace: NAMESPACE
                }).promise();
              })
              .then(() => cb())
              .catch(cb);
          };
      Handler: 'index.handler'
      MemorySize: 128
      Role: !GetAtt 'SchedulableContainersLambdaRole.Arn'
      Runtime: 'nodejs6.10'
      Timeout: 60

  SchedulableContainersLambdaErrorsTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Invocations failed due to errors in the function'
      Namespace: 'AWS/Lambda'
      MetricName: Errors
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 0
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"
      Dimensions:
        - Name: FunctionName
          Value: !Ref SchedulableContainersLambda

  SchedulableContainersLambdaThrottlesTooHighAlarm:
    Condition: HasAlertTopic
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: 'Invocation attempts that were throttled due to invocation rates exceeding the concurrent limits'
      Namespace: 'AWS/Lambda'
      MetricName: Throttles
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 0
      AlarmActions:
        - Fn::ImportValue: !Sub "${ParentAlertStack}-TopicARN"
      Dimensions:
        - Name: FunctionName
          Value: !Ref SchedulableContainersLambda

Outputs:
  StackName:
    Description: 'Stack name'
    Value: !Ref 'AWS::StackName'

  Cluster:
    Description: 'ECS cluster.'
    Value: !Ref Cluster
    Export:
      Name: !Sub "${AWS::StackName}-Cluster"

  ClusterVolume:
    Description: 'ECS Cluster shared volume path'
    Value: !Ref EFSDirectory
    Export:
      Name: !Sub "${AWS::StackName}-Volume"

  LoadBalancerFullName:
    Description: 'ALB full name for services.'
    Value: !GetAtt 'LoadBalancer.LoadBalancerFullName'
    Export:
      Name: !Sub "${AWS::StackName}-LoadBalancerFullName"

  LoadBalancer:
    Description: 'ALB ARN for services.'
    Value: !Ref LoadBalancer
    Export:
      Name: !Sub "${AWS::StackName}-LoadBalancer"

  LoadBalancerSecurityGroup:
    Description: 'ALB Security Group for services.'
    Value: !Ref ALBSecurityGroup
    Export:
      Name: !Sub "${AWS::StackName}-LoadBalancerSecurityGroup"

  HttpListener:
    Description: 'ALB HTTP listener for services.'
    Value: !Ref HttpListener
    Export:
      Name: !Sub "${AWS::StackName}-HttpListener"

  HttpsListener:
    Condition: HasLoadBalancerCertificateArn
    Description: 'ALB HTTPS listener for services.'
    Value: !Ref HttpsListener
    Export:
      Name: !Sub "${AWS::StackName}-HttpsListener"

  CanonicalHostedZoneID:
    Description: 'The ID of the Amazon Route 53 hosted zone associated with the load balancer.'
    Value: !GetAtt LoadBalancer.CanonicalHostedZoneID
    Export:
      Name: !Sub "${AWS::StackName}-CanonicalHostedZoneID"

  SecurityGroup:
    Description: 'Security Group of ECS cluster.'
    Value: !Ref SecurityGroup
    Export:
      Name: !Sub "${AWS::StackName}-SecurityGroup"

  LogGroup:
    Description: 'Log group of ECS cluster.'
    Value: !Ref LogGroup
    Export:
      Name: !Sub "${AWS::StackName}-LogGroup"

  DNSName:
    Description: 'The DNS name for the ECS cluster load balancer.'
    Value: !GetAtt 'LoadBalancer.DNSName'
    Export:
      Name: !Sub "${AWS::StackName}-DNSName"

  URL:
    Description: 'URL to the ECS cluster.'
    Value: !Sub "http://${LoadBalancer.DNSName}"
    Export:
      Name: !Sub "${AWS::StackName}-URL"
